<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>객체매서드</title>
    <script>
        // + computed property(계산된 프로퍼티)
        let a = 'name';
        let b = 'age';

        let user = {
            [a]: 'Tom',
            [b]: 30,
            [1+3]:4
        }
        console.log(user);

        // + 생성자 함수를 사용
        // 첫번째 매개변수가 Key,
        // 두번째 매개변수가 value가 되도록 객체를 만들기

        function Exercise (key, value) {
            // this.key = value; 키명이 반영 안됨
            // [this.key] = value; 키명이 반영 안됨
            return {
                [key]:value
            }
        }
        let exercise1 = new Exercise('키', '값');
        console.log(exercise1);

        // + 객체 복제, 합치기
        // Object.assign({},복제할 객체명);
        let person = {
            name: 'Jane',
            age: 20,
        }   
        // let clonePerson = person;
        // => 복사가 아닌 객체 내용이 저장된 주소의 참조값만 복사됨     
        // person.naeme="Tom";
        // console.log(person);
        // console.log(clonePerson);

        let clonePerson = Object.assign({},person);
        // => {} 객체에 초기값
        // => person 객체가 {}로 인해 하나 복제됨
        person.name = "Mike";
        console.log(person);
        console.log(clonePerson);
        // => person과 clonePerson은 서로 다른 객체임
        
        // + 합치기
        // Object.assign(합치는 객체1, 합치는 객체2, ...);
        let info1 = {
            name: 'Jane',
        }
        let info2 = {
            age: 30,
        }
        let info3 = {
            gender: 'female',
        }
        let newObject = Object.assign(info1, info2, info3);
        console.log(newObject);

        let human = {
            name:'Jane',
            age:20,
            gender:'female'
        }
        // + key, value를 배열로 반환하는 방법
        // 1. key만 배열로 반환
        // Object.keys();
        let keyArr = Object.keys(human);
        console.log(keyArr);       

        // 2. value만 배열로 반환
        // Object.values();
        let valueArr = Object.values(human);
        console.log(valueArr);

        // 3. key, value를 둘다 배열로 반환
        // Object.entries();
        let entArr = Object.entries(human);
        console.log(entArr);

        // 4. key, value 쌍으로 묶은 배열을 객체로 반환
        // Object.fromEntries();
        let arr = [ 
            ['name','Tom'], 
            ['age',40], 
            ['gender','male']
        ]
        let newArrObject = Object.fromEntries(arr);
        console.log(newArrObject);

        // + 문제 각 키와 값 매개변수로 하는 생성자 함수를 만들어 3개의 객체를 만들고 
        // 만든 객체 3개를 하나로 합치기
        // 각 개체 출력
        // 합친 객체 출력

        function Ex (key, value) {
            return {
                [key]:value
            }
        }
        let ex1 = new Ex('name', 'a');
        let ex2 = new Ex('age', '20');
        let ex3 = new Ex('gender', 'male');
        let newEx = Object.assign({}, ex1, ex2, ex3);
        // => Object.assign() 작업시 동일한 키는 합치기 작업시 덮어쓰기됨
        console.log(ex1);
        console.log(ex2);
        console.log(ex3);
        console.log(newEx);

        // ex3에 새로운 키와 내용을 추가 한 후 합치기 작업하기
        ex3.hobby = 'football';
        console.log(ex3);
        let newEx1 = Object.assign({}, ex1, ex2, ex3);
        console.log(newEx1);
        // => 다른 키가 있으면 다른 키는 추가되면서 합쳐짐
</script>
</head>
<body>
    
</body>
</html>